"""
Parallel ideation system for generating and consolidating ideas from multiple AI sub-agents.
"""
from typing import List, Dict, Any, Optional
from pydantic import BaseModel
import asyncio
import google.generativeai as genai
from loguru import logger
import json
from concurrent.futures import ThreadPoolExecutor
from dataclasses import dataclass
from datetime import datetime
import os
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

@dataclass
class IdeationContext:
    """Context for the ideation process."""
    product_specs: str
    market_context: Optional[str] = None
    technical_constraints: Optional[List[str]] = None
    innovation_targets: Optional[List[str]] = None
    session_id: str = datetime.now().strftime("%Y%m%d_%H%M%S")

class IdeaFragment(BaseModel):
    """A partial idea generated by a sub-agent."""
    concept: str
    approach: List[str]
    potential_impact: float
    innovation_score: float
    feasibility_score: float
    specialization: str
    rationale: Optional[str] = None

class SubAgentResult(BaseModel):
    """Result from a single sub-agent including multiple idea fragments."""
    agent_id: str
    fragments: List[IdeaFragment]
    specialization: str
    confidence_score: float
    insights: Optional[List[str]] = None

class ParallelIdeationSystem:
    def __init__(self, model: str = "gemini-2.0-flash", num_agents: int = 3):
        """Initialize the parallel ideation system with multiple Gemini instances."""
        self.model = model
        self.num_agents = num_agents
        
        # Configure Gemini
        api_key = os.getenv("GEMINI_API_KEY")
        if not api_key:
            raise ValueError("GEMINI_API_KEY not found in environment variables")
        genai.configure(api_key=api_key)
        
        # Define sub-agent specializations with detailed focus areas
        self.specializations = {
            "Technical Innovation": {
                "focus": ["emerging technologies", "novel approaches", "technical feasibility"],
                "weight": 0.25
            },
            "User Experience": {
                "focus": ["usability", "accessibility", "user engagement"],
                "weight": 0.20
            },
            "Market Opportunity": {
                "focus": ["market fit", "competitive advantage", "scalability"],
                "weight": 0.20
            },
            "Implementation Feasibility": {
                "focus": ["resource requirements", "timeline", "risk assessment"],
                "weight": 0.20
            },
            "Integration Architecture": {
                "focus": ["system design", "interoperability", "maintainability"],
                "weight": 0.15
            }
        }
        
        # Initialize Gemini clients for each agent
        self.clients = [genai.GenerativeModel(model) for _ in range(num_agents)]
    
    async def generate_idea_fragments(self, 
                                    context: IdeationContext, 
                                    agent_id: int,
                                    specialization: str) -> SubAgentResult:
        """Generate idea fragments from a single sub-agent with specific specialization."""
        try:
            # Create specialized prompt
            focus_areas = self.specializations[specialization]["focus"]
            prompt = f"""You are a specialized innovation agent focused on {specialization}.
            Your expertise covers: {', '.join(focus_areas)}
            
            Product Specifications:
            {context.product_specs}
            
            {f'Market Context: {context.market_context}' if context.market_context else ''}
            {f'Technical Constraints: {json.dumps(context.technical_constraints)}' if context.technical_constraints else ''}
            {f'Innovation Targets: {json.dumps(context.innovation_targets)}' if context.innovation_targets else ''}
            
            Generate 2-3 innovative solution fragments focusing on your specialization.
            
            For each fragment, provide:
            1. Core concept
            2. Technical/implementation approach
            3. Impact assessment (0-10)
            4. Innovation score (0-10)
            5. Feasibility score (0-10)
            6. Rationale for scores
            
            Format as JSON with fields matching the IdeaFragment model.
            """
            
            # Generate fragments
            response = await asyncio.to_thread(
                self.clients[agent_id].generate_content,
                prompt
            )
            
            fragments_data = json.loads(response.text)
            fragments = [IdeaFragment(**fragment) for fragment in fragments_data]
            
            # Calculate confidence score based on fragment quality
            confidence_score = sum(f.innovation_score * f.feasibility_score for f in fragments) / len(fragments) / 100
            
            return SubAgentResult(
                agent_id=f"agent_{agent_id}",
                fragments=fragments,
                specialization=specialization,
                confidence_score=confidence_score
            )
            
        except Exception as e:
            logger.error(f"Error in sub-agent {agent_id} ({specialization}): {str(e)}")
            raise
    
    async def generate_ideas(self, context: IdeationContext) -> List[IdeaFragment]:
        """Run parallel ideation with multiple specialized sub-agents."""
        try:
            # Assign specializations to agents
            agent_specs = []
            for i in range(self.num_agents):
                spec = list(self.specializations.keys())[i % len(self.specializations)]
                agent_specs.append((i, spec))
            
            # Generate fragments in parallel
            tasks = [
                self.generate_idea_fragments(context, agent_id, spec)
                for agent_id, spec in agent_specs
            ]
            
            results = await asyncio.gather(*tasks)
            
            # Combine all fragments
            all_fragments = []
            for result in results:
                all_fragments.extend(result.fragments)
            
            return all_fragments
            
        except Exception as e:
            logger.error(f"Error in parallel ideation: {str(e)}")
            raise
