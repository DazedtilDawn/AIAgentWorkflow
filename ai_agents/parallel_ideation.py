"""
Parallel ideation system for generating and consolidating ideas from multiple AI sub-agents.
"""
from typing import List, Dict, Any, Optional
from pydantic import BaseModel
import asyncio
import google.generativeai as genai
from loguru import logger
import json
from concurrent.futures import ThreadPoolExecutor
from dataclasses import dataclass
from datetime import datetime

class IdeaFragment(BaseModel):
    """A partial idea generated by a sub-agent."""
    concept: str
    approach: List[str]
    potential_impact: float
    innovation_score: float
    feasibility_score: float
    specialization: str
    rationale: Optional[str] = None

class SubAgentResult(BaseModel):
    """Result from a single sub-agent including multiple idea fragments."""
    agent_id: str
    fragments: List[IdeaFragment]
    specialization: str
    confidence_score: float
    insights: Optional[List[str]] = None

@dataclass
class IdeationContext:
    """Context for the ideation process."""
    product_specs: str
    market_context: Optional[str] = None
    technical_constraints: Optional[List[str]] = None
    innovation_targets: Optional[List[str]] = None
    session_id: str = datetime.now().strftime("%Y%m%d_%H%M%S")

class ParallelIdeationSystem:
    def __init__(self, model: str = "gemini-2.0-flash", num_agents: int = 3):
        """Initialize the parallel ideation system with multiple Gemini instances."""
        self.model = model
        self.num_agents = num_agents
        
        # Define sub-agent specializations with detailed focus areas
        self.specializations = {
            "Technical Innovation": {
                "focus": ["emerging technologies", "novel approaches", "technical feasibility"],
                "weight": 0.25
            },
            "User Experience": {
                "focus": ["usability", "accessibility", "user engagement"],
                "weight": 0.20
            },
            "Market Opportunity": {
                "focus": ["market fit", "competitive advantage", "scalability"],
                "weight": 0.20
            },
            "Implementation Feasibility": {
                "focus": ["resource requirements", "timeline", "risk assessment"],
                "weight": 0.20
            },
            "Integration Architecture": {
                "focus": ["system design", "interoperability", "maintainability"],
                "weight": 0.15
            }
        }
        
        # Initialize Gemini clients for each agent
        self.clients = []
        for _ in range(num_agents):
            client = genai.GenerativeModel(model)
            self.clients.append(client)
    
    async def generate_idea_fragments(self, 
                                    context: IdeationContext, 
                                    agent_id: int,
                                    specialization: str) -> SubAgentResult:
        """Generate idea fragments from a single sub-agent with specific specialization."""
        try:
            # Construct the prompt with context and specialization
            context_str = ""
            if context.market_context:
                context_str += f"\nMarket Context:\n{context.market_context}"
            if context.technical_constraints:
                context_str += f"\nTechnical Constraints:\n{json.dumps(context.technical_constraints, indent=2)}"
            if context.innovation_targets:
                context_str += f"\nInnovation Targets:\n{json.dumps(context.innovation_targets, indent=2)}"

            prompt = f"""As a specialized AI agent focused on {specialization}, analyze this product specification:

            {context.product_specs}
            {context_str}

            Generate innovative ideas considering your specialization in {specialization}, focusing on:
            {json.dumps(self.specializations[specialization]['focus'], indent=2)}

            For each idea, provide:
            1. Core concept
            2. Implementation approach
            3. Impact and feasibility scores (0-1)
            4. Clear rationale for the approach
            
            Format as JSON with fields:
            - concept: string
            - approach: list of strings
            - potential_impact: float
            - innovation_score: float
            - feasibility_score: float
            - rationale: string
            """

            response = await self.clients[agent_id].generate_content(prompt)
            fragments_data = json.loads(response.text)
            
            # Convert to IdeaFragment objects
            fragments = []
            for frag in fragments_data:
                frag["specialization"] = specialization
                fragments.append(IdeaFragment(**frag))
            
            return SubAgentResult(
                agent_id=f"agent_{agent_id}",
                fragments=fragments,
                specialization=specialization,
                confidence_score=sum(f.feasibility_score * f.potential_impact for f in fragments) / len(fragments),
                insights=[f"Insight from {specialization}: {f.rationale}" for f in fragments if f.rationale]
            )
            
        except Exception as e:
            logger.error(f"Error in sub-agent {agent_id} ({specialization}): {str(e)}")
            return SubAgentResult(
                agent_id=f"agent_{agent_id}",
                fragments=[],
                specialization=specialization,
                confidence_score=0.0,
                insights=[f"Error in ideation: {str(e)}"]
            )
    
    async def consolidate_fragments(self, 
                                  results: List[SubAgentResult], 
                                  context: IdeationContext) -> List[Dict[str, Any]]:
        """Consolidate idea fragments into cohesive solution ideas using weighted scoring."""
        try:
            # Collect all fragments with their specialization weights
            weighted_fragments = []
            for result in results:
                for fragment in result.fragments:
                    weight = self.specializations[fragment.specialization]["weight"]
                    weighted_score = (
                        fragment.potential_impact * 0.4 +
                        fragment.innovation_score * 0.3 +
                        fragment.feasibility_score * 0.3
                    ) * weight
                    
                    weighted_fragments.append({
                        "fragment": fragment,
                        "weight": weight,
                        "weighted_score": weighted_score,
                        "specialization": result.specialization
                    })
            
            # Sort fragments by weighted score
            weighted_fragments.sort(key=lambda x: x["weighted_score"], reverse=True)
            
            # Generate consolidated ideas prompt
            consolidation_prompt = f"""Consolidate these solution fragments into cohesive ideas:

            Fragments (sorted by score):
            {json.dumps([{
                "concept": f["fragment"].concept,
                "approach": f["fragment"].approach,
                "specialization": f["fragment"].specialization,
                "score": f["weighted_score"]
            } for f in weighted_fragments], indent=2)}
            
            Product Context:
            {context.product_specs}
            
            Create 3-5 consolidated solutions that:
            1. Combine complementary ideas
            2. Resolve any conflicts
            3. Maximize overall value
            
            Format as JSON array with fields:
            - title: string
            - description: string
            - key_features: list of strings
            - technical_approach: list of strings
            - source_fragments: list of concept strings
            - synergy_score: float
            """
            
            response = await self.clients[0].generate_content(consolidation_prompt)
            consolidated_ideas = json.loads(response.text)
            
            # Add metadata to each consolidated idea
            for idea in consolidated_ideas:
                idea["contributing_specializations"] = list(set(
                    f["specialization"] for f in weighted_fragments
                    if any(frag in idea["source_fragments"] for frag in [f["fragment"].concept])
                ))
                
                # Calculate final score based on synergy and specialization coverage
                specialization_coverage = len(idea["contributing_specializations"]) / len(self.specializations)
                idea["final_score"] = (idea["synergy_score"] * 0.7 + specialization_coverage * 0.3)
            
            # Sort by final score
            consolidated_ideas.sort(key=lambda x: x["final_score"], reverse=True)
            return consolidated_ideas
            
        except Exception as e:
            logger.error(f"Error consolidating ideas: {str(e)}")
            raise
    
    async def run_parallel_ideation(self, context: IdeationContext) -> List[Dict[str, Any]]:
        """Run the parallel ideation process with multiple specialized sub-agents."""
        try:
            # Distribute specializations among agents
            agent_tasks = []
            for i in range(self.num_agents):
                # Cycle through specializations
                specialization = list(self.specializations.keys())[i % len(self.specializations)]
                task = self.generate_idea_fragments(context, i, specialization)
                agent_tasks.append(task)
            
            # Run sub-agents in parallel
            results = await asyncio.gather(*agent_tasks)
            
            # Filter out empty results
            valid_results = [r for r in results if r.fragments]
            
            if not valid_results:
                raise ValueError("No valid ideas generated by sub-agents")
            
            # Consolidate and score ideas
            consolidated_ideas = await self.consolidate_fragments(valid_results, context)
            
            # Log ideation session summary
            logger.info(f"Ideation session {context.session_id} completed:")
            logger.info(f"- Sub-agents participated: {len(valid_results)}")
            logger.info(f"- Total fragments generated: {sum(len(r.fragments) for r in valid_results)}")
            logger.info(f"- Consolidated ideas produced: {len(consolidated_ideas)}")
            
            return consolidated_ideas
            
        except Exception as e:
            logger.error(f"Error in parallel ideation: {str(e)}")
            raise
